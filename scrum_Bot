import logging
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackContext,
)
from apscheduler.schedulers.background import BackgroundScheduler

TOKEN = "7505034345:AAEloodyEV8Nz6-332e_RWck8HPP78uAARY"  # Replace with your actual bot token
GROUP_ID = "-1002423544865"  # Replace with your group ID

# Dictionary to store user responses and states
user_responses = {}

# Logger setup
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO)


# Function to start the bot and register the user
async def start(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    user_name = update.message.from_user.full_name  # Get the full name

    # Register the user if not already registered
    if user_id not in user_responses:
        user_responses[user_id] = {"name": user_name, "state": None}

    print(f"User Registered: {user_id} - {user_name}"
          )  # Print registered user info

    await update.message.reply_text(
        "Hi! I'll collect your daily standup updates. Expect a message from me daily!"
    )


# Function to ask the first question
async def ask_question_1(user_id: int, context: CallbackContext):
    print(
        f"Sending Question 1 to: {user_responses[user_id]['name']} ({user_id})"
    )  # Debugging
    await context.bot.send_message(chat_id=user_id,
                                   text="1Ô∏è‚É£ What did you finish yesterday?")
    user_responses[user_id]["state"] = "QUESTION_1"


# Function to ask the second question
async def ask_question_2(user_id: int, context: CallbackContext):
    print(
        f"Sending Question 2 to: {user_responses[user_id]['name']} ({user_id})"
    )  # Debugging
    await context.bot.send_message(chat_id=user_id,
                                   text="2Ô∏è‚É£ What will you finish today?")
    user_responses[user_id]["state"] = "QUESTION_2"


# Function to ask the third question
async def ask_question_3(user_id: int, context: CallbackContext):
    print(
        f"Sending Question 3 to: {user_responses[user_id]['name']} ({user_id})"
    )  # Debugging
    await context.bot.send_message(chat_id=user_id, text="3Ô∏è‚É£ Any blockers?")
    user_responses[user_id]["state"] = "QUESTION_3"


# Function to handle user responses
async def handle_response(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    user_name = update.message.from_user.full_name  # Get the full name

    # Ensure user info is stored
    if user_id not in user_responses:
        user_responses[user_id] = {"name": user_name, "state": "QUESTION_1"}

    state = user_responses[user_id].get("state")

    if state == "QUESTION_1":
        user_responses[user_id]["yesterday"] = update.message.text
        print(
            f"Response from {user_responses[user_id]['name']} (Yesterday): {update.message.text}"
        )  # Debugging
        user_responses[user_id]["state"] = "QUESTION_2"
        await ask_question_2(user_id, context)
    elif state == "QUESTION_2":
        user_responses[user_id]["today"] = update.message.text
        print(
            f"Response from {user_responses[user_id]['name']} (Today): {update.message.text}"
        )  # Debugging
        user_responses[user_id]["state"] = "QUESTION_3"
        await ask_question_3(user_id, context)
    elif state == "QUESTION_3":
        user_responses[user_id]["blockers"] = update.message.text
        print(
            f"Response from {user_responses[user_id]['name']} (Blockers): {update.message.text}"
        )  # Debugging
        user_responses[user_id]["state"] = "COMPLETED"
        await update.message.reply_text(
            "‚úÖ Thank you! Your response is recorded.")


# Function to send questions to all registered users
async def collect_responses(context: CallbackContext):
    print("Collecting responses from registered users...")  # Debugging
    for user_id, data in user_responses.items():
        print(f"Sending standup questions to {data['name']} ({user_id})"
              )  # Debugging
        await ask_question_1(user_id, context)


# Function to compile and send the final report
async def send_summary(context: CallbackContext):
    message = "**üìä Daily Standup Summary:**\n\n"

    print("Compiling daily summary...")  # Debugging
    for user_id, data in user_responses.items():
        user_name = data.get('name', 'Unknown User')  # Fetch actual name
        message += f"**{user_name}**\n"
        message += f"üîπ *Yesterday:* {data.get('yesterday', 'Not answered')}\n"
        message += f"üîπ *Today:* {data.get('today', 'Not answered')}\n"
        message += f"üîπ *Blockers:* {data.get('blockers', 'None')}\n\n"

    if message.strip() == "**üìä Daily Standup Summary:**\n\n":
        message += "No responses recorded today."

    print("Final Summary Message:")  # Debugging
    print(message)  # Print full summary before sending

    await context.bot.send_message(GROUP_ID, message, parse_mode="Markdown")


# Main function to start the bot
def main():
    # Create the Application
    application = Application.builder().token(TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_response))

    # Schedule the bot to send questions & summary
    scheduler = BackgroundScheduler()
    scheduler.add_job(
        lambda: application.job_queue.run_once(collect_responses, when=0),
        "cron",
        hour=20,
        minute=31)
    scheduler.add_job(
        lambda: application.job_queue.run_once(send_summary, when=0),
        "cron",
        hour=20,
        minute=33)
    scheduler.start()

    # Start the bot
    application.run_polling()


if __name__ == "__main__":
    main()
