import logging
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    CallbackContext,
)
from apscheduler.schedulers.background import BackgroundScheduler

TOKEN = "7505034345:AAEloodyEV8Nz6-332e_RWck8HPP78uAARY"  # Replace with your bot token
GROUP_ID = "-1002423544865" 

# Dictionary to store user responses and states
user_responses = {}

# Logger setup
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# Function to start the bot
async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Hi! I'll collect your daily standup updates. Expect a message from me daily!")

# Function to ask the first question
async def ask_question_1(user_id: int, context: CallbackContext):
    await context.bot.send_message(chat_id=user_id, text="1Ô∏è‚É£ What did you finish yesterday?")
    user_responses[user_id] = {"name": "User", "state": "QUESTION_1"}

# Function to ask the second question
async def ask_question_2(user_id: int, context: CallbackContext):
    await context.bot.send_message(chat_id=user_id, text="2Ô∏è‚É£ What will you finish today?")
    user_responses[user_id]["state"] = "QUESTION_2"

# Function to ask the third question
async def ask_question_3(user_id: int, context: CallbackContext):
    await context.bot.send_message(chat_id=user_id, text="3Ô∏è‚É£ Any blockers?")
    user_responses[user_id]["state"] = "QUESTION_3"

# Function to handle user responses
async def handle_response(update: Update, context: CallbackContext):
    user_id = update.message.from_user.id
    if user_id not in user_responses:
        return

    state = user_responses[user_id].get("state")
    if state == "QUESTION_1":
        user_responses[user_id]["yesterday"] = update.message.text
        await ask_question_2(user_id, context)
    elif state == "QUESTION_2":
        user_responses[user_id]["today"] = update.message.text
        await ask_question_3(user_id, context)
    elif state == "QUESTION_3":
        user_responses[user_id]["blockers"] = update.message.text
        user_responses[user_id]["state"] = "COMPLETED"
        await update.message.reply_text("‚úÖ Thank you! Your response is recorded.")

# Function to send questions to all users in the group
async def collect_responses(context: CallbackContext):
    bot = context.bot
    group_members = await bot.get_chat_administrators(GROUP_ID)  # Get all admins (or use a user list)

    for member in group_members:
        if not member.user.is_bot:  # Ignore bots
            await ask_question_1(member.user.id, context)

# Function to compile and send the final report
async def send_summary(context: CallbackContext):
    message = "**üìä Daily Standup Summary:**\n\n"

    for user_id, data in user_responses.items():
        if data.get("state") == "COMPLETED":
            message += f"**{data.get('name', 'User')}**\n"
            message += f"üîπ *Yesterday:* {data.get('yesterday', 'Not answered')}\n"
            message += f"üîπ *Today:* {data.get('today', 'Not answered')}\n"
            message += f"üîπ *Blockers:* {data.get('blockers', 'None')}\n\n"

    await context.bot.send_message(GROUP_ID, message, parse_mode="Markdown")

# Main function to start the bot
def main():
    # Create the Application
    application = Application.builder().token(TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_response))

    # Schedule the bot to send questions & summary
    scheduler = BackgroundScheduler()
    scheduler.add_job(lambda: application.job_queue.run_once(collect_responses, when=0), "cron", hour=18, minute=44)  # Ask at 4:30 PM
    scheduler.add_job(lambda: application.job_queue.run_once(send_summary, when=0), "cron", hour=18, minute=46)  # Summarize at 4:45 PM
    scheduler.start()

    # Start the bot
    application.run_polling()

if __name__ == "__main__":
    main()
